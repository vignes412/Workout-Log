/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL, PrecacheEntry } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// Import types for service worker
/// <reference lib="webworker" />

// Define Clients and Client interfaces
interface Clients {
  get(id: string): Promise<Client | undefined>;
  matchAll(options?: ClientQueryOptions): Promise<Client[]>;
  openWindow(url: string): Promise<WindowClient | null>;
  claim(): Promise<void>;
}

interface ClientQueryOptions {
  includeUncontrolled?: boolean;
  type?: 'window' | 'worker' | 'sharedworker' | 'all';
}

interface Client {
  id: string;
  type: 'window' | 'worker' | 'sharedworker';
  url: string;
  postMessage(message: any, transfer?: any[]): void;
}

interface WindowClient extends Client {
  focused: boolean;
  visibilityState: 'hidden' | 'visible' | 'prerender' | 'unloaded';
  focus(): Promise<WindowClient>;
  navigate(url: string): Promise<WindowClient | null>;
}

// Extend the ServiceWorkerGlobalScope interface to include missing properties
declare global {
  interface ServiceWorkerGlobalScope {
    __WB_MANIFEST: (string | PrecacheEntry)[];
    skipWaiting: () => Promise<void>;
    clients: Clients;
    addEventListener: (
      type: string, 
      listener: (event: any) => void, 
      options?: boolean | AddEventListenerOptions
    ) => void;
  }
}

declare const self: ServiceWorkerGlobalScope;

// Make service worker take control immediately
clientsClaim();

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Set up app shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');

// Return index.html for all navigation requests
registerRoute(
  ({ request, url }: { request: Request; url: URL }) => {
    // If this is a navigation request
    if (request.mode === 'navigate') {
      // If it's not for a file with an extension or an API call
      return !url.pathname.startsWith('/api/') && 
        !fileExtensionRegexp.test(url.pathname);
    }
    return false;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Create a background sync queue for failed mutations (POST/PUT)
const bgSyncPlugin = new BackgroundSyncPlugin('workout-log-queue', {
  maxRetentionTime: 24 * 60, // Retry for 24 Hours (in minutes)
  onSync: async ({ queue }) => {
    // This will be triggered when the background sync executes
    console.log('Background sync is running.');
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        // Retry the request
        const { request } = entry;
        await fetch(request);
        
        // Notify clients that data was synced
        const clients = await self.clients.matchAll({ type: 'window' });
        for (const client of clients) {
          client.postMessage({
            type: 'BACKGROUND_SYNC_COMPLETED',
            url: request.url
          });
        }
      } catch (error) {
        console.error('Replay failed for request', entry.request, error);
        
        // Re-throw the error to trigger a retry
        // Add to the queue again with increasing delay
        await queue.unshiftRequest(entry);
        throw error;
      }
    }
  },
});

// Setup API routes with different caching strategies

// API requests that modify data - use background sync for offline support
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/') && 
    !['GET', 'HEAD'].includes(new URL(url).searchParams.get('method') || 'GET'),
  new NetworkFirst({
    networkTimeoutSeconds: 10,
    cacheName: 'api-write-requests',
    plugins: [
      bgSyncPlugin,
      new CacheableResponsePlugin({
        statuses: [0, 200]
      })
    ]
  }),
  'POST'
);

// Same for PUT requests
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    networkTimeoutSeconds: 10,
    cacheName: 'api-write-requests',
    plugins: [
      bgSyncPlugin,
      new CacheableResponsePlugin({
        statuses: [0, 200]
      })
    ]
  }),
  'PUT'
);

// GET API requests - use Network First with a timeout
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-read-requests',
    networkTimeoutSeconds: 5,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 24 hours
        purgeOnQuotaError: true,
      }),
    ],
  }),
  'GET'
);

// Google APIs - use Network First with a timeout
registerRoute(
  ({ url }) => url.hostname.includes('googleapis.com'),
  new NetworkFirst({
    cacheName: 'google-apis',
    networkTimeoutSeconds: 3,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 6 * 60 * 60, // 6 hours
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache styles, scripts, and workers - use Stale While Revalidate
registerRoute(
  ({ request, url }) => 
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker' ||
    url.pathname.endsWith('.css') ||
    url.pathname.endsWith('.js'),
  new StaleWhileRevalidate({
    cacheName: 'assets',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache images - use Cache First
registerRoute(
  ({ request, url }) => 
    request.destination === 'image' ||
    url.pathname.match(/\.(jpg|jpeg|png|gif|webp|svg|ico)$/),
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache font files - use Cache First
registerRoute(
  ({ request, url }) => 
    request.destination === 'font' ||
    url.pathname.match(/\.(woff|woff2|ttf|otf|eot)$/),
  new CacheFirst({
    cacheName: 'fonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 24 * 60 * 60, // 60 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Listen for the user clicking the "Update" button
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Serve a special offline page when there's no internet connection
registerRoute(
  // Match any navigation request when offline
  ({ request }) => 
    request.mode === 'navigate' && 
    !navigator.onLine,
  // Serve the offline page
  async () => {
    try {
      // Try to fetch the offline page from cache
      const cache = await caches.open('offline-pages');
      const cachedResponse = await cache.match('/offline.html');
      if (cachedResponse) {
        return cachedResponse;
      }
      
      // If not in cache, try to fetch it from network
      const networkResponse = await fetch('/offline.html');
      if (networkResponse.ok) {
        // Cache it for future use
        await cache.put('/offline.html', networkResponse.clone());
        return networkResponse;
      }
      
      // If all else fails, return a basic HTML response
      return new Response(
        `<html>
          <head>
            <title>Offline - Workout Log</title>
            <style>
              body {
                font-family: sans-serif;
                text-align: center;
                padding: 20px;
                background: #1a202c;
                color: #e2e8f0;
              }
              h1 { margin-bottom: 20px; }
              p { margin-bottom: 10px; }
              button {
                background: #63b3ed;
                border: none;
                color: white;
                padding: 10px 20px;
                border-radius: 4px;
                cursor: pointer;
              }
            </style>
          </head>
          <body>
            <h1>You're Offline</h1>
            <p>The Workout Log app requires an internet connection.</p>
            <p>Some features may be available offline if you've used them before.</p>
            <button onclick="window.location.reload()">Try Again</button>
          </body>
        </html>`,
        {
          headers: { 'Content-Type': 'text/html' }
        }
      );
    } catch (error) {
      console.error('Error serving offline page:', error);
      return new Response('You are offline. Please reconnect to the internet.', {
        headers: { 'Content-Type': 'text/plain' }
      });
    }
  }
);

// Create a function to handle token refresh
async function refreshAuthToken() {
  try {
    const clients = await self.clients.matchAll();
    for (const client of clients) {
      client.postMessage({
        type: 'AUTH_REFRESH_NEEDED'
      });
    }
  } catch (error) {
    console.error('Failed to refresh auth token:', error);
  }
}

// Periodically refresh auth token when service worker is active
self.addEventListener('activate', (event) => {
  event.waitUntil(
    (async () => {
      // Refresh immediately on activate
      await refreshAuthToken();
      
      // Set up periodic refresh
      setInterval(refreshAuthToken, 50 * 60 * 1000); // Every 50 minutes
    })()
  );
});